#!/usr/bin/env python3

#
# Copyright 2023 Signal Messenger, LLC
# SPDX-License-Identifier: AGPL-3.0-only
#

import argparse
import html
import plistlib
import sys

from collections.abc import Iterable
from typing import Dict, Tuple, TextIO


def parse(input: TextIO, filename: str) -> Dict[str, str]:
    # The format is
    #     # webrtc
    #     ```
    #     LICENSE INFO GOES HERE
    #     POSSIBLY SEVERAL LINES OF IT
    #     ```
    # repeated for each library
    result = dict()
    line_number = 0

    def readline() -> str:
        nonlocal line_number
        line_number += 1
        return input.readline()

    def fatal(msg: str) -> None:
        raise Exception(f'{filename}:{line_number}: {msg}')

    while True:
        line = readline()
        if not line:
            # EOF
            break
        line = line.strip()
        if not line:
            # Ignore blank lines between dependencies.
            continue

        # Expect a dependency line.
        if not line.startswith('# '):
            fatal(f'unexpected line: "{line.strip()}"')
        name = line[2:]

        # Expect the start of a fenced license.
        line = readline()
        if line != '```\n':
            if not line:
                fatal('unexpected end of file')
            line = line.strip()
            if not line:
                fatal('unexpected blank line')
            fatal(f'unexpected line: "{line.strip()}"')

        license = ''
        while True:
            line = readline()
            if line == '' or line == '```\n':
                # Break on the end fence or on EOF.
                break
            # These probably shouldn't be escaped in the first place, but they are.
            license += html.unescape(line)

        result[name] = license

    return result


def print_as_markdown(deps: Iterable[Tuple[str, str]]) -> None:
    # We're approximating the format in Signal-Desktop/ACKNOWLEDGMENTS.plist
    for name, license in deps:
        print('##', name)
        print()
        print('```')
        # The license already has a trailing newline.
        print(license, end='')
        print('```')
        print()


def print_as_plist(deps: Iterable[Tuple[str, str]]) -> None:
    # We're trying to match the format in Signal-iOS/Signal/Settings.bundle/Acknowledgements.plist
    # which comes from <https://developer.apple.com/library/archive/documentation/PreferenceSettings/Conceptual/SettingsApplicationSchemaReference/Introduction/Introduction.html>.
    plistlib.dump(fp=sys.stdout.buffer, value={
        'PreferenceSpecifiers': [
            {
                'FooterText': 'RingRTC depends on the WebRTC project',
                'Title': 'Acknowledgments',
                'Type': 'PSGroupSpecifier',
            }
        ] + [
            {
                'FooterText': license,
                'Title': name,
                'Type': 'PSGroupSpecifier',
            } for name, license in deps
        ] + [
            {
                'FooterText': 'Generated in RingRTC',
                'Title': '',
                'Type': 'PSGroupSpecifier',
            }
        ],
        'StringsTable': 'Acknowledgments',
        'Title': 'Acknowledgments',
    })
    sys.stdout.flush()


def main() -> None:
    parser = argparse.ArgumentParser(
        description='Convert WebRTC LICENSE.md to other formats')
    parser.add_argument('-f', '--format', choices=['md', 'plist'],
                        help='Output format (Markdown or iOS Settings.plist)')
    parser.add_argument('files', nargs='+', metavar='LICENSE.md',
                        help='License file(s) generated by WebRTC')
    args = parser.parse_args()

    dependencies = dict()
    for path in args.files:
        with open(path) as f:
            dependencies.update(parse(f, path))

    # Sort the dependencies, but always put WebRTC first.
    webrtc_dep = dependencies.pop('webrtc')
    sorted_dependencies = [('webrtc', webrtc_dep)] + sorted(dependencies.items())

    if args.format == 'md':
        # Same as input format, but merges multiple files.
        print_as_markdown(sorted_dependencies)
    elif args.format == 'plist':
        print_as_plist(sorted_dependencies)
    else:
        print([name for (name, _) in sorted_dependencies])


if __name__ == '__main__':
    main()
